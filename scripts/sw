#!/usr/bin/env python3

import os
import shlex
import sys
import subprocess
import argparse
import yaml
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import re
import logging

# Setup debug logging
log_file = Path(os.environ.get('XDG_CACHE_HOME', Path.home() / '.cache')) / 'dotfiles' / 'sw.log'
logging.basicConfig(filename=log_file, level=logging.DEBUG, format='DEBUG: %(message)s')

CONFIG_DIR = Path(os.environ.get('XDG_CONFIG_HOME', Path.home() / '.config')) / 'dotfiles'
CONFIG_FILE =  CONFIG_DIR / 'sw.yaml'
FZF_PREVIEWER = CONFIG_DIR / "fzf_preview.sh"

def normalize_path(path: str) -> Path:
    path = os.path.expanduser(path)
    path = os.path.expandvars(path)
    return Path(path).absolute()

def resolve_handler_path(handler_override: str) -> Path:
    handler_path = Path(handler_override)
    if handler_path.is_absolute():
        return handler_path
    else:
        return CONFIG_FILE.parent / handler_override

def validate_config() -> bool:
    if not CONFIG_FILE.exists():
        print(f"Error: Config file not found at {CONFIG_FILE}", file=sys.stderr)
        return False
    
    try:
        with open(CONFIG_FILE) as f:
            config = yaml.safe_load(f)
            if 'projects' not in config:
                raise ValueError("Missing 'projects' key")
        return True
    except Exception as e:
        print(f"Error: Invalid YAML in {CONFIG_FILE}: {e}", file=sys.stderr)
        return False

def load_config() -> Dict:
    with open(CONFIG_FILE) as f:
        return yaml.safe_load(f)

def get_projects() -> List[Tuple[str, Path, str]]:
    if not validate_config():
        return []
    
    config = load_config()
    projects = []
    
    for name, details in config.get('projects', {}).items():
        path = normalize_path(details['path'])
        if path.is_dir():
            tmux_session = details.get('tmux', '')
            projects.append((name, path, tmux_session))
    
    return projects

def validate_handler_config(name: str, details: Dict) -> bool:
    handler_pattern = details.get('handler_pattern', '')
    handler_override = details.get('handler_override', '')
    
    if bool(handler_pattern) != bool(handler_override):
        print(f"Error: Project '{name}' has handler_pattern but no handler_override (or vice versa)", file=sys.stderr)
        print(f"{name}:", file=sys.stderr)
        for key, value in details.items():
            print(f"  {key}: {repr(value)}", file=sys.stderr)
        return False
    return True

def get_current_project() -> Optional[Tuple[str, Path, str, str, str, str, str]]:
    current_dir = Path(os.getcwd()).absolute()
    current_resolved = Path(os.getcwd()).resolve()
    
    logging.debug(f"current_dir={current_dir}")
    logging.debug(f"current_resolved={current_resolved}")
    
    config = load_config()
    
    for name, details in config.get('projects', {}).items():
        if not validate_handler_config(name, details):
            sys.exit(1)
            
        project_path = normalize_path(details['path'])
        project_str = str(project_path).rstrip('/')
        
        for check_dir in [current_dir, current_resolved]:
            check_str = str(check_dir).rstrip('/')
            logging.debug(f"checking project {name}, path={project_str} against {check_str}")
            
            if project_path.is_dir() and (check_str == project_str or check_str.startswith(project_str + '/')):
                logging.debug(f"MATCH found for {name}")
                return (
                    name,
                    project_path,
                    details.get('tmux', ''),
                    details.get('filter_for', ''),
                    details.get('filter_out', ''),
                    details.get('handler_pattern', ''),
                    details.get('handler_override', '')
                )
    
    logging.debug("no project match found")
    return None

def change_to_directory(path: Path, on_enter_cmd: str | None = None, path_only: bool = False):
    if path_only:
        print(f"{path}")
    else:
        print(f"cd '{path}'")
        if on_enter_cmd:
            print(on_enter_cmd)

def find_project_files(project_path: Path, filter_for: str, filter_out: str, handler_pattern: str, handler_override: str, path_only: bool = False, use_gui: bool = False):
    logging.debug(f"find_project_files called with path={project_path}, filter_for={filter_for}, filter_out={filter_out}, handler_pattern={handler_pattern}")
    
    project_path_str = str(project_path)
    quoted_abs_project_path_str_for_env = shlex.quote(project_path_str)
    fzf_preview_script_path_str = str(FZF_PREVIEWER)
    quoted_fzf_preview_script_path_str = shlex.quote(fzf_preview_script_path_str)
    fzf_preview_arg = (
        f"env PROJECT_PATH_ENV_VAR={quoted_abs_project_path_str_for_env} "
        f"{quoted_fzf_preview_script_path_str} {{}}"
    )
    
    find_cmd = ['fd', '--base-directory', str(project_path), '--type', 'f', '--hidden', '--follow', '--exclude', '.git', '--color=always']
    
    if use_gui:
        dmenu_cmd = [
            'dmenu',
            '-l', '30',
            '-i',
            '-c',
            '--class', 'sw',
            '-p', 'File'
        ]
        
        try:
            find_proc = subprocess.Popen(find_cmd, stdout=subprocess.PIPE, text=True)
            dmenu_proc = subprocess.Popen(dmenu_cmd, stdin=find_proc.stdout, stdout=subprocess.PIPE, text=True)
            
            if find_proc.stdout:
                find_proc.stdout.close()
            
            selected_file, _ = dmenu_proc.communicate()
            
            if dmenu_proc.returncode == 0 and selected_file.strip():
                selected_file = selected_file.strip()
                logging.debug(f"selected_file={selected_file}")
                
                full_path = project_path / selected_file
                
                if full_path.is_dir():
                    change_to_directory(full_path, path_only=path_only)
                else:
                    if handler_pattern and handler_override:
                        pattern = re.compile(handler_pattern)
                        if pattern.search(str(full_path)):
                            handler_script = resolve_handler_path(handler_override)
                            if handler_script.is_file() and os.access(handler_script, os.X_OK):
                                if path_only:
                                    print(f"{full_path}")
                                else:
                                    subprocess.run([str(handler_script), str(full_path)])
                                return
                            else:
                                print(f"Error: Handler script {handler_script} not found or not executable", file=sys.stderr)
                                return
                    
                    if path_only:
                        print(f"{full_path}")
                    else:
                        mime_result = subprocess.run(['file', '--mime-type', '-b', str(full_path)], capture_output=True, text=True)
                        mime_type = mime_result.stdout.strip()
                        
                        default_app_result = subprocess.run(['xdg-mime', 'query', 'default', mime_type], capture_output=True, text=True)
                        default_app = default_app_result.stdout.strip()
                        
                        if default_app == 'neovide.desktop':
                            editor = os.environ.get('EDITOR', 'nvim')
                            print(f"{editor} '{full_path}'")
                        else:
                            print(f"xdg-open '{full_path}'")
        
        except subprocess.CalledProcessError:
            pass
    else:
        fzf_cmd = [
            'fzf',
            '--ansi',
            '--preview', fzf_preview_arg,
            '--preview-window=right:50%:border-left:noinfo',
            '--border=rounded',
            '--color=bg+:#313244,bg:#1e1e2e,spinner:#f5e0dc,hl:#f38ba8',
            '--color=fg:#cdd6f4,header:#f38ba8,info:#cba6ac,pointer:#f5e0dc',
            '--color=marker:#f5e0dc,fg+:#cdd6f4,prompt:#cba6ac,hl+:#f38ba8',
            '--bind=ctrl-u:preview-page-up,ctrl-d:preview-page-down',
            '--cycle'
        ]
        
        try:
            find_proc = subprocess.Popen(find_cmd, stdout=subprocess.PIPE, text=True)
            fzf_proc = subprocess.Popen(fzf_cmd, stdin=find_proc.stdout, stdout=subprocess.PIPE, text=True)
            
            if find_proc.stdout:
                find_proc.stdout.close()
            
            selected_file, _ = fzf_proc.communicate()
            
            if fzf_proc.returncode == 0 and selected_file.strip():
                selected_file = selected_file.strip()
                logging.debug(f"selected_file={selected_file}")
                
                full_path = project_path / selected_file
                
                if full_path.is_dir():
                    change_to_directory(full_path, path_only=path_only)
                else:
                    if handler_pattern and handler_override:
                        pattern = re.compile(handler_pattern)
                        if pattern.search(str(full_path)):
                            handler_script = resolve_handler_path(handler_override)
                            if handler_script.is_file() and os.access(handler_script, os.X_OK):
                                if path_only:
                                    print(f"{full_path}")
                                else:
                                    subprocess.run([str(handler_script), str(full_path)])
                                return
                            else:
                                print(f"Error: Handler script {handler_script} not found or not executable", file=sys.stderr)
                                return
                    
                    if path_only:
                        print(f"{full_path}")
                    else:
                        if is_text_file(full_path):
                            editor = os.environ.get('EDITOR', 'nvim')
                            print(f"{editor} '{full_path}'")
                        else:
                            print(f"xdg-open '{full_path}'")
        except subprocess.CalledProcessError:
            pass

def is_text_file(filepath):
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            f.read(8192)  # Read first 8KB
        return True
    except (UnicodeDecodeError, PermissionError):
        return False

def create_project_session(name: str, path: Path) -> bool:
    if not path.is_dir():
        print(f"Error: Directory {path} does not exist", file=sys.stderr)
        return False
    
    result = subprocess.run(['tmux', 'new-session', '-d', '-s', name, '-c', str(path)])
    return result.returncode == 0

def project_exists(name: str) -> bool:
    result = subprocess.run(['tmux', 'has-session', '-t', name], capture_output=True)
    return result.returncode == 0

def attach_project(name: str) -> bool:
    if project_exists(name):
        if os.environ.get('TMUX'):
            subprocess.run(['tmux', 'detach-client'])
        subprocess.run(['tmux', 'attach-session', '-t', name])
        return True
    else:
        print(f"Error: Session {name} does not exist", file=sys.stderr)
        return False

def switch_project(path_only: bool = False, use_gui = False):
    config = load_config()
    for name, details in config.get('projects', {}).items():
        if not validate_handler_config(name, details):
            sys.exit(1)

    # Skip current project check when path_only is True
    if not path_only:
        current_project = get_current_project()
        if current_project:
            name, path, tmux_session, filter_for, filter_out, handler_pattern, handler_override = current_project
            find_project_files(path, filter_for, filter_out, handler_pattern, handler_override, path_only)
            return
    
    
    projects = get_projects()
    if not projects:
        print("No projects found", file=sys.stderr)
        return
    
    project_lines = []
    for name, path, tmux_session in projects:
        project_lines.append(f"{name}|{path}|{tmux_session}")
    

    if use_gui:
        dmenu_cmd = [
            'dmenu',
            '-l', '30',
            '-i',
            '-c',
            '--class', 'sw',
            '-p', 'Project'
        ]
        
        try:
            # For dmenu, we'll just show project names
            project_names = [name for name, _, _ in projects]
            
            result = subprocess.run(
                dmenu_cmd,
                input='\n'.join(project_names),
                text=True,
                capture_output=True
            )
            
            if result.returncode == 0:
                selected_name = result.stdout.strip()
                if selected_name:
                    # Find the selected project
                    for name, path, tmux_session in projects:
                        if name == selected_name:
                            if path_only:
                                print(f"{path}")
                            elif tmux_session:
                                os.chdir(path)
                                if project_exists(tmux_session):
                                    if os.environ.get('TMUX'):
                                        subprocess.run(['tmux', 'detach-client'])
                                    subprocess.run(['tmux', 'attach-session', '-t', tmux_session])
                                else:
                                    create_project_session(tmux_session, path)
                                    if os.environ.get('TMUX'):
                                        subprocess.run(['tmux', 'detach-client'])
                                    subprocess.run(['tmux', 'attach-session', '-t', tmux_session])
                            else:
                                change_to_directory(path, path_only=path_only)
                                on_enter_cmd = config.get('projects', {}).get(name, {}).get('on_enter')
                                if on_enter_cmd:
                                    print(on_enter_cmd)
                            break
        
        except subprocess.CalledProcessError:
            pass
    else:
        fzf_cmd = [
                'fzf',
                '--delimiter=|',
                '--with-nth=1',
                '--preview=echo "Name: {1}\nPath: {2}"',
                '--algo=v2',
                '--border=rounded',
                '--color=bg+:#313244,bg:#1e1e2e,spinner:#f5e0dc,hl:#f38ba8',
                '--color=fg:#cdd6f4,header:#f38ba8,info:#cba6ac,pointer:#f5e0dc',
                '--color=marker:#f5e0dc,fg+:#cdd6f4,prompt:#cba6ac,hl+:#f38ba8',
                '--bind=ctrl-u:preview-page-up,ctrl-d:preview-page-down',
                '--cycle'
        ]
        
        try:
            result = subprocess.run(
                fzf_cmd,
                input='\n'.join(project_lines),
                text=True,
                capture_output=True
            )
            
            if result.returncode == 0:
                selected = result.stdout.strip()
                if selected:
                    parts = selected.split('|')
                    name, path, tmux_session = parts[0], Path(parts[1]), parts[2] if len(parts) > 2 else ''
                    
                    if path_only:
                        print(f"{path}")
                    elif tmux_session:
                        os.chdir(path)
                        if project_exists(tmux_session):
                            if os.environ.get('TMUX'):
                                subprocess.run(['tmux', 'detach-client'])
                            subprocess.run(['tmux', 'attach-session', '-t', tmux_session])
                        else:
                            create_project_session(tmux_session, path)
                            if os.environ.get('TMUX'):
                                subprocess.run(['tmux', 'detach-client'])
                            subprocess.run(['tmux', 'attach-session', '-t', tmux_session])
                    else:
                        change_to_directory(path, path_only=path_only)
                        on_enter_cmd = config.get('projects', {}).get(name, {}).get('on_enter')
                        if on_enter_cmd:
                            print(on_enter_cmd)

        
        except subprocess.CalledProcessError:
            pass
def start():
    projects = get_projects()
    for name, path, tmux_session in projects:
        if tmux_session and not project_exists(tmux_session):
            create_project_session(tmux_session, path)

def list_projects():
    print("Projects:")
    projects = get_projects()
    
    for name, path, tmux_session in projects:
        if tmux_session:
            status = "✓" if project_exists(tmux_session) else "✗"
        else:
            status = "📁"
        print(f"  {status} {name}")

def get_start_path():
    """Determines the starting path: Git root if available, otherwise CWD."""
    cwd = Path(os.getcwd())
    
    try:
        result = subprocess.run(
            ['git', 'rev-parse', '--show-toplevel'],
            cwd=cwd,
            capture_output=True,
            text=True,
            check=True
        )
        return Path(result.stdout.strip())
        
    except (subprocess.CalledProcessError, FileNotFoundError):
        return cwd

def main():
    parser = argparse.ArgumentParser(description='Project switcher with tmux integration')
    parser.add_argument('--path', '-p', action='store_true', help='Output only the path, forces switch mode')
    parser.add_argument('--gui', '-g', action='store_true', help='Use dmenu instead of fzf for selection')
    subparsers = parser.add_subparsers(dest='command', help='Commands')
    
    parser.set_defaults(command='switch')
    
    subparsers.add_parser('switch', aliases=['s'], help='Interactive project picker (default)')
    subparsers.add_parser('list', aliases=['l'], help='Show project status')
    subparsers.add_parser('find', aliases=['f'], help='Find files in current directory')
    
    attach_parser = subparsers.add_parser('attach', aliases=['a'], help='Attach to project session')
    attach_parser.add_argument('name', help='Project name')
    
    subparsers.add_parser('start', help='Start all project sessions')
    
    args = parser.parse_args()

    validate_config()
    
    # Force switch mode when --path is used
    if args.path:
        switch_project(path_only=True, use_gui=args.gui)
    elif args.command in ['switch', 's', None]:
        switch_project(path_only=False, use_gui=args.gui)
    elif args.command in ['list', 'l']:
        list_projects()
    elif args.command in ['find', 'f']:
        find_project_files(get_start_path(), '', '', '', '', args.path, args.gui)
    elif args.command in ['attach', 'a']:
        attach_project(args.name)
    elif args.command == 'start':
        start()
    else:
        parser.print_help()
        sys.exit(1)

if __name__ == '__main__':
    main()
