#!/bin/bash

# Default values
MAX_DIST=5
INPUT_DIR=""

# Function to print usage information
usage() {
    echo "Usage: $0 --dir <directory> [--dist <max_distance>]"
    echo "  --dir  : Directory containing images to group"
    echo "  --dist : Maximum Levenshtein distance for grouping (default: 5, must be an integer)"
    exit 1
}

# Function to calculate Levenshtein distance between two strings
levenshtein() {
    local s1="$1"
    local s2="$2"
    local len1=${#s1}
    local len2=${#s2}
    
    # Create a matrix to store distances
    declare -A d
    
    # Initialize first row and column
    for ((i=0; i<=len1; i++)); do
        d["$i,0"]=$i
    done
    
    for ((j=0; j<=len2; j++)); do
        d["0,$j"]=$j
    done
    
    # Calculate distances
    for ((i=1; i<=len1; i++)); do
        for ((j=1; j<=len2; j++)); do
            if [[ "${s1:i-1:1}" == "${s2:j-1:1}" ]]; then
                cost=0
            else
                cost=1
            fi
            
            deletion=$((d["$((i-1)),$j"] + 1))
            insertion=$((d["$i,$((j-1))"] + 1))
            substitution=$((d["$((i-1)),$((j-1))"] + cost))
            
            d["$i,$j"]=$(( deletion < insertion ? deletion : insertion ))
            d["$i,$j"]=$(( d["$i,$j"] < substitution ? d["$i,$j"] : substitution ))
        done
    done
    
    echo ${d["$len1,$len2"]}
}

# Function to find the longest common substring between two strings
longest_common_substring() {
    local s1="$1"
    local s2="$2"
    local max_len=0
    local result=""
    
    local len1=${#s1}
    local len2=${#s2}
    
    for ((i=0; i<len1; i++)); do
        for ((j=0; j<len2; j++)); do
            local k=0
            while (( i+k < len1 && j+k < len2 && ${s1:i+k:1} == ${s2:j+k:1} )); do
                k=$((k+1))
            done
            
            if (( k > max_len )); then
                max_len=$k
                result=${s1:i:k}
            fi
        done
    done
    
    echo "$result"
}

# Function to find longest common substring for multiple strings
find_lcs_for_group() {
    local file_list=("$@")
    local count=${#file_list[@]}
    
    # If there's only one file, return its base name without extension
    if [ $count -eq 1 ]; then
        basename "${file_list[0]}" | sed 's/\.[^.]*$//'
        return
    fi
    
    # Start with the base name (without extension) of the first file
    local base1=$(basename "${file_list[0]}" | sed 's/\.[^.]*$//')
    local lcs="$base1"
    
    # Compare with each other file
    for ((i=1; i<count; i++)); do
        local base2=$(basename "${file_list[i]}" | sed 's/\.[^.]*$//')
        lcs=$(longest_common_substring "$lcs" "$base2")
    done
    
    # If LCS is empty or just whitespace, use a fallback name
    if [ -z "${lcs// /}" ]; then
        echo "group"
    else
        # Clean up the LCS - remove trailing spaces and special characters
        lcs=$(echo "$lcs" | sed 's/[^a-zA-Z0-9]$//' | sed 's/[^a-zA-Z0-9 _-]//g' | sed 's/ /_/g')
        # Ensure the name is not empty after cleaning
        if [ -z "$lcs" ]; then
            echo "group"
        else
            echo "$lcs"
        fi
    fi
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        --dir)
            INPUT_DIR="$2"
            shift
            shift
            ;;
        --dist)
            # Validate that the distance is an integer
            if [[ "$2" =~ ^[0-9]+$ ]]; then
                MAX_DIST="$2"
            else
                echo "Error: Distance must be an integer"
                usage
            fi
            shift
            shift
            ;;
        *)
            echo "Unknown option: $1"
            usage
            ;;
    esac
done

# Check if required arguments are provided
if [ -z "$INPUT_DIR" ]; then
    echo "Error: Input directory is required"
    usage
fi

# Check if the directory exists
if [ ! -d "$INPUT_DIR" ]; then
    echo "Error: Directory '$INPUT_DIR' does not exist"
    usage
fi

# Get all image files
IMAGES=($(find "$INPUT_DIR" -maxdepth 1 -type f -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" -o -name "*.gif" -o -name "*.bmp" -o -name "*.tiff" -o -name "*.webp"))

if [ ${#IMAGES[@]} -eq 0 ]; then
    echo "No image files found in '$INPUT_DIR'"
    exit 0
fi

echo "Found ${#IMAGES[@]} image files in '$INPUT_DIR'"
echo "Using maximum distance: $MAX_DIST"

# Calculate the total number of comparisons needed
NUM_IMAGES=${#IMAGES[@]}
TOTAL_COMPARISONS=$(( (NUM_IMAGES * (NUM_IMAGES - 1)) / 2 ))
echo "Analyzing similarity... ($TOTAL_COMPARISONS total comparisons)"

# Initialize a counter for the number of groups created
GROUP_COUNT=0
# Initialize a counter for the number of comparisons done
COMPARISONS_DONE=0

# Create a temporary array to track which images have been processed
PROCESSED=()
for ((i=0; i<${#IMAGES[@]}; i++)); do
    PROCESSED[$i]=0
done

# Create a temporary directory to store group information
TEMP_DIR=$(mktemp -d)
trap 'rm -rf "$TEMP_DIR"' EXIT

# First, analyze and build groups without creating directories
GROUP_DIRS=()
GROUP_NAMES=()
TEMP_DIRS=()

# Print initial progress
printf "Progress: 0%%"

for ((i=0; i<${#IMAGES[@]}; i++)); do
    # Skip if this image has already been processed
    if [ ${PROCESSED[$i]} -eq 1 ]; then
        continue
    fi
    
    # Mark this image as processed
    PROCESSED[$i]=1
    
    # Get base filename without extension for comparison
    FILENAME_1=$(basename "${IMAGES[$i]}")
    BASE_1="${FILENAME_1%.*}"
    
    # Create a new group
    GROUP_COUNT=$((GROUP_COUNT + 1))
    TEMP_GROUP_DIR="$INPUT_DIR/group_$GROUP_COUNT"
    TEMP_DIRS+=("$TEMP_GROUP_DIR")
    
    # Create a file to store this group's data
    GROUP_FILE="$TEMP_DIR/group_$GROUP_COUNT"
    echo "${IMAGES[$i]}" > "$GROUP_FILE"
    
    # Find similar images
    for ((j=i+1; j<${#IMAGES[@]}; j++)); do
        if [ ${PROCESSED[$j]} -eq 1 ]; then
            continue
        fi
        
        FILENAME_2=$(basename "${IMAGES[$j]}")
        BASE_2="${FILENAME_2%.*}"
        
        # Calculate Levenshtein distance
        DISTANCE=$(levenshtein "$BASE_1" "$BASE_2")
        
        # If distance is below the threshold, add to the same group
        if [ "$DISTANCE" -le "$MAX_DIST" ]; then
            echo "${IMAGES[$j]}" >> "$GROUP_FILE"
            PROCESSED[$j]=1
        fi
        
        # Update progress counter
        COMPARISONS_DONE=$((COMPARISONS_DONE + 1))
        PERCENT=$((COMPARISONS_DONE * 100 / TOTAL_COMPARISONS))
        printf "\rProgress: %d%% (%d/%d comparisons)" $PERCENT $COMPARISONS_DONE $TOTAL_COMPARISONS
    done
done

# Print a newline after the progress counter
echo -e "\n"

echo "Determining group names based on longest common substrings..."

# Now determine group names based on longest common substring
for ((g=1; g<=GROUP_COUNT; g++)); do
    GROUP_FILE="$TEMP_DIR/group_$g"
    
    # Read files into an array
    mapfile -t GROUP_FILES < "$GROUP_FILE"
    
    # Find longest common substring for this group
    GROUP_NAME=$(find_lcs_for_group "${GROUP_FILES[@]}")
    
    # Ensure the name is unique by adding a suffix if needed
    BASE_NAME="$GROUP_NAME"
    SUFFIX=1
    while [[ " ${GROUP_NAMES[*]} " =~ " ${GROUP_NAME} " ]]; do
        GROUP_NAME="${BASE_NAME}_$SUFFIX"
        SUFFIX=$((SUFFIX + 1))
    done
    
    GROUP_NAMES+=("$GROUP_NAME")
    GROUP_DIRS+=("$INPUT_DIR/$GROUP_NAME")
done

# Display the planned directory structure and ask for confirmation
echo "Analysis complete! Found $GROUP_COUNT potential groups."
echo "Creating directories:"

for ((g=1; g<=GROUP_COUNT; g++)); do
    GROUP_FILE="$TEMP_DIR/group_$g"
    GROUP_SIZE=$(wc -l < "$GROUP_FILE")
    echo -e "\nGroup $g: '${GROUP_NAMES[$g-1]}' (${GROUP_SIZE} files) -> ${GROUP_DIRS[$g-1]}"
    
    # Display up to 5 example files for each group
    DISPLAY_COUNT=$((GROUP_SIZE > 5 ? 5 : GROUP_SIZE))
    head -n "$DISPLAY_COUNT" "$GROUP_FILE" | while read -r FILE_PATH; do
        echo "  - $(basename "$FILE_PATH")"
    done
    
    if [ $GROUP_SIZE -gt 5 ]; then
        echo "  - ... and $((GROUP_SIZE - 5)) more files"
    fi
done

# Ask for confirmation
echo -e "\nConfirm creation of $GROUP_COUNT directories? [y/n]"
read -r CONFIRM

if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
    echo "Creating directories and copying files..."
    
    # Create directories and copy files
    for ((g=1; g<=GROUP_COUNT; g++)); do
        mkdir -p "${GROUP_DIRS[$g-1]}"
        GROUP_FILE="$TEMP_DIR/group_$g"
        
        while read -r FILE_PATH; do
            cp "$FILE_PATH" "${GROUP_DIRS[$g-1]}/"
        done < "$GROUP_FILE"
        
        GROUP_SIZE=$(wc -l < "$GROUP_FILE")
        echo "Created group '${GROUP_NAMES[$g-1]}' with $GROUP_SIZE files"
    done
    
    echo "Grouping complete! Created $GROUP_COUNT groups."
    echo "Original files remain in the original directory."
    echo "Grouped copies are in subdirectories."
else
    echo "Operation cancelled. No directories were created."
fi
